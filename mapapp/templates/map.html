<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Bus Routes Demo</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #topbar {
      padding: 8px 12px;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
    }

    #map {
      width: 100%;
      height: calc(100% - 46px);
    }

    select {
      padding: 4px 8px;
      min-width: 220px;
    }

    /* Simple toast-like message box */
    #messageBox {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 4px;
      font-size: 13px;
      display: none;
      z-index: 999;
    }
  </style>
</head>

<body>
  <div id="topbar">
    <label for="routeSelect">Route:</label>
    <select id="routeSelect">
      <option value="">-- Select a route --</option>
      {% for r in routes %}
      <option value="{{ r.MaTuyen }}">
        {{ r.MaTuyen }} - {{ r.TenTuyen }}
      </option>
      {% endfor %}
    </select>

    <label for="directionSelect" style="margin-left: 12px;">Direction:</label>
    <select id="directionSelect">
      <option value="0">Chiều đi</option>
      <option value="1">Chiều về</option>
    </select>
  </div>


  <div id="map"></div>
  <div id="messageBox"></div>

  <div id="addStopPanel" style="position:absolute;top:80px;right:10px;width:260px;
              background:#fff;border:1px solid #ccc;border-radius:4px;
              padding:8px;font-size:13px;z-index:999;display:none;box-shadow:0 2px 6px rgba(0,0,0,0.2);">
  </div>


  <button id="cancelRouteChangesBtn" style="position:absolute;bottom:60px;left:calc(50% + 140px);padding:8px 14px;
                display:none;z-index:999;
                background:#f44336;color:white;border:none;border-radius:4px;cursor:pointer;">
    Cancel
  </button>

  <button id="applyRouteChangesBtn" style="position:absolute;bottom:60px;left:50%;transform:translateX(-50%);
                padding:8px 14px;display:none;z-index:999;
                background:#2196F3;color:white;border:none;border-radius:4px;cursor:pointer;">
    Apply changes
  </button>


  <!-- Google Maps JS with key from .env -->
  <script src="https://maps.googleapis.com/maps/api/js?key={{ GG_API_KEY }}"></script>

  <script>
    const STOPS = JSON.parse('{{ stops_json|escapejs }}');
    const ROUTES = JSON.parse('{{ routes_json|escapejs }}');
    const ROUTE_INFO = {};
    ROUTES.forEach(r => ROUTE_INFO[r.MaTuyen] = r);


    let map;
    let currentPolyline = null;
    let stopMarkers = [];

    // stop editing
    let selectedStop = null;
    let isChangingLocation = false;

    // route editing
    let editMode = false;
    let selectedVertexIndex = null;
    let awaitingAddNodeClick = false;
    let currentRouteMaTuyen = null;
    let currentRouteChieu = "0";   // "0" đi, "1" về
    let polylinePath = null;       // google.maps.MVCArray
    let routeInfoWindow = null;
    let vertexInfoWindow = null;

    let messageTimeoutId = null;

    let originalRouteBackup = null;

    let pendingStopLatLng = null;
    let routeStopsCache = [];

    //
    // TYPE 2 (Điểm dừng)  — triangles
    //
    const iconTriangleRed = {
      path: "M 0,6 L -5,-3 L 5,-3 z",   // downward triangle
      fillColor: "#d32f2f",
      fillOpacity: 1,
      strokeColor: "#ffffff",
      strokeWeight: 1,
      scale: 1.4
    };

    const iconTriangleGreen = {
      path: "M 0,6 L -5,-3 L 5,-3 z",
      fillColor: "#4CAF50",
      fillOpacity: 1,
      strokeColor: "#ffffff",
      strokeWeight: 1,
      scale: 1.4
    };


    //
    // TYPE 1 (Bến xe) — hexagons
    //
    const iconHexagonRed = {
      path: "M -5,0 L -2.5,-4.3 L 2.5,-4.3 L 5,0 L 2.5,4.3 L -2.5,4.3 z",
      fillColor: "#d32f2f",
      fillOpacity: 1,
      strokeColor: "#ffffff",
      strokeWeight: 1,
      scale: 1.2
    };

    const iconHexagonGreen = {
      path: "M -5,0 L -2.5,-4.3 L 2.5,-4.3 L 5,0 L 2.5,4.3 L -2.5,4.3 z",
      fillColor: "#4CAF50",
      fillOpacity: 1,
      strokeColor: "#ffffff",
      strokeWeight: 1,
      scale: 1.2
    };



    function showMessage(text, timeout = 3000) {
      const box = document.getElementById("messageBox");
      box.textContent = text;
      box.style.display = "block";

      if (messageTimeoutId) clearTimeout(messageTimeoutId);
      messageTimeoutId = setTimeout(() => {
        box.style.display = "none";
      }, timeout);
    }

    function initMap() {
      const center = { lat: 10.776, lng: 106.700 }; // adjust
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 12,
        center: center,
      });

      // STOP MARKERS
      STOPS.forEach(stop => {
        createStopMarker(stop);
      });

      // MAP CLICK: used for both stop-move and route Add node
      map.addListener("click", (event) => {
        const newLatLng = event.latLng;

        // 1) route Add node (highest priority)
        if (editMode && awaitingAddNodeClick && selectedVertexIndex !== null && polylinePath) {
          const insertIndex = selectedVertexIndex; // insert before selected
          polylinePath.insertAt(insertIndex, newLatLng);
          awaitingAddNodeClick = false;
          selectedVertexIndex = null;
          showMessage("Node added.", 2000);
          return;
        }

        // 2) stop location change
        if (isChangingLocation && selectedStop) {
          selectedStop.setPosition(newLatLng);
          selectedStop.stopData.lat = newLatLng.lat();
          selectedStop.stopData.lng = newLatLng.lng();
          isChangingLocation = false;

          showMessage("Saving new stop location...");

          fetch("/update-stop-location/", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              MaTram: selectedStop.stopData.MaTram,
              lat: newLatLng.lat(),
              lng: newLatLng.lng(),
            }),
          })
            .then((res) => res.json())
            .then((data) => {
              if (!data.success) {
                showMessage("Stop moved, but DB update failed: " + data.error, 5000);
              } else {
                showMessage("Stop location updated.", 2500);
              }
            })
            .catch((err) => {
              console.error(err);
              showMessage("Stop moved, but error updating DB.", 5000);
            });

          return;
        }
      });

      map.addListener("rightclick", async (event) => {
        if (!currentRouteMaTuyen) {
          showMessage("Select a route and direction first.", 3000);
          return;
        }

        pendingStopLatLng = event.latLng;
        await openAddStopPanel();
      });

    }

    // ROUTE LOADING + DRAWING WITH DIRECTION ARROWS + START/END
    async function loadAndDrawRoute() {
      const maTuyen = document.getElementById("routeSelect").value;
      const chieu = document.getElementById("directionSelect").value;

      currentRouteMaTuyen = maTuyen || null;
      currentRouteChieu = chieu;

      // exit edit mode if switching route/direction
      if (editMode) {
        exitRouteEditMode();
      }

      if (!maTuyen) {
        if (currentPolyline) {
          currentPolyline.setMap(null);
          currentPolyline = null;
        }
        return;
      }

      const res = await fetch(`/route-path/?MaTuyen=${encodeURIComponent(maTuyen)}&Chieu=${encodeURIComponent(chieu)}`);
      if (!res.ok) {
        console.error("Failed to load route", await res.text());
        showMessage("Failed to load route", 4000);
        return;
      }
      const data = await res.json();
      const path = data.path || [];
      if (!path.length) {
        showMessage("Route has no path geometry.", 3000);
        return;
      }

      routeVertices = path.slice(); // keep a copy for editing

      if (currentPolyline) {
        currentPolyline.setMap(null);
        currentPolyline = null;
      }

      const start = routeVertices[0];
      const end = routeVertices[routeVertices.length - 1];

      currentPolyline = new google.maps.Polyline({
        path: routeVertices,
        map: map,
        strokeWeight: 2,
        strokeColor: "#0d47a1",
        editable: false,
        icons: [
          // direction arrows
          {
            icon: {
              path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
              scale: 2.5,
              strokeOpacity: 0.9,
            },
            offset: "5%",
            repeat: "5%",
          },
          // start = blue dot
          {
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 4,
              fillColor: "#0000ff",
              fillOpacity: 1,
              strokeColor: "#0000ff",
              strokeWeight: 1,
            },
            offset: "0%",
          },
          // end = red X
          {
            icon: {
              path: "M -2,-2 L 2,2 M 2,-2 L -2,2",
              strokeColor: "#ff0000",
              strokeWeight: 2,
              scale: 2.5,
            },
            offset: "100%",
          },
        ],
      });

      // get reference to the path
      polylinePath = currentPolyline.getPath();

      // single click handler, behavior depends on editMode
      if (!routeInfoWindow) routeInfoWindow = new google.maps.InfoWindow();
      if (!vertexInfoWindow) vertexInfoWindow = new google.maps.InfoWindow();

      currentPolyline.addListener("click", (e) => {
        // if in edit mode, clicking on a vertex selects that vertex
        if (editMode) {
          if (typeof e.vertex === "number") {
            selectedVertexIndex = e.vertex;
            const idx = e.vertex;
            const content = `
              <div>
                <b>Node #${idx}</b><br/>
                <button id="addNodeBtn" type="button"
                        style="background:#4CAF50;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;">
                  Add node
                </button>
                <button id="delNodeBtn" type="button"
                        style="background:#f44336;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;margin-left:6px;">
                  Delete node
                </button>
                <button id="delNodeBeyondBtn" type="button"
                        style="background:#f44336;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;margin-left:6px;">
                  Delete node and beyond
                </button>
              </div>
            `;
            vertexInfoWindow.setContent(content);
            vertexInfoWindow.setPosition(e.latLng);
            vertexInfoWindow.open(map);

            google.maps.event.addListenerOnce(vertexInfoWindow, "domready", () => {
              const addBtn = document.getElementById("addNodeBtn");
              const delBtn = document.getElementById("delNodeBtn");
              const delBeyondBtn = document.getElementById("delNodeBeyondBtn");

              if (addBtn) {
                addBtn.onclick = () => {
                  awaitingAddNodeClick = true;
                  showMessage("Click on the map to insert a new node before this one.");
                };
              }
              if (delBtn) {
                delBtn.onclick = () => {
                  if (polylinePath.getLength() <= 2) {
                    showMessage("Cannot delete, route needs at least 2 points.", 4000);
                    return;
                  }
                  polylinePath.removeAt(idx);
                  selectedVertexIndex = null;
                  vertexInfoWindow.close();
                  showMessage("Node deleted.", 2000);
                };
              }
              if (delBeyondBtn) {
                delBeyondBtn.onclick = () => {
                  if (idx === 0) {
                    showMessage("Cannot delete from first node; route would be empty.", 4000);
                    return;
                  }
                  if (polylinePath.getLength() - idx < 2) {
                    showMessage("Need at least two nodes left on the route.", 4000);
                    return;
                  }
                  for (let i = polylinePath.getLength() - 1; i >= idx; i--) {
                    polylinePath.removeAt(i);
                  }
                  selectedVertexIndex = null;
                  vertexInfoWindow.close();
                  showMessage("Node and all following nodes deleted.", 2000);
                };
              }
            });
          }
          return;
        }

        // NOT in edit mode → show route info + Edit button
        if (!currentRouteMaTuyen) return;

        const r = ROUTE_INFO[currentRouteMaTuyen];

        const content = `
            <div>
              <b>Route ${currentRouteMaTuyen} — ${r.TenTuyen}</b><br/>
              Direction: ${currentRouteChieu === "0" ? "Chiều đi" : "Chiều về"}<br/><br/>

              <table style="font-size:12px;">
                <tr><td><b>Độ dài:</b></td><td>${r.DoDai ?? '–'} km</td></tr>
                <tr><td><b>Giá vé:</b></td><td>${r.GiaVe ?? '–'} đ</td></tr>
                <tr><td><b>Thời gian toàn tuyến:</b></td><td>${r.ThoiGianToanTuyen ?? '–'} phút</td></tr>
                <tr><td><b>Bắt đầu:</b></td><td>${r.GioBatDay ?? '–'}</td></tr>
                <tr><td><b>Kết thúc:</b></td><td>${r.GioKetThuc ?? '–'}</td></tr>
                <tr><td><b>Giữa 2 chuyến:</b></td><td>${r.ThoiGianGiua2Tuyen ?? '–'} phút</td></tr>
                <tr><td><b>Số chuyến:</b></td><td>${r.SoChuyen ?? '–'}</td></tr>
              </table>

              <button id="editRouteBtn" type="button"
                      style="background:#2196F3;color:white;border:none;padding:5px 10px;
                            border-radius:4px;margin-top:6px;cursor:pointer;">
                Edit route
              </button>
            </div>
          `;

        routeInfoWindow.setContent(content);
        routeInfoWindow.setPosition(e.latLng);
        routeInfoWindow.open(map);

        google.maps.event.addListenerOnce(routeInfoWindow, "domready", () => {
          const btn = document.getElementById("editRouteBtn");
          if (!btn) return;
          btn.onclick = () => {
            enterRouteEditMode();
            routeInfoWindow.close();
          };
        });
      });

      const bounds = new google.maps.LatLngBounds();
      routeVertices.forEach(pt => bounds.extend(pt));

      // only recenter if route is NOT currently visible
      if (!isRouteVisible(bounds)) {
        map.fitBounds(bounds);
      }

      await updateStopIconsForCurrentRoute();
    }

    function refreshPolylineFromVertices() {
      if (!currentPolyline) return;
      currentPolyline.setPath(routeVertices);
    }

    // ROUTE EDIT MODE
    function enterRouteEditMode() {
      if (!currentPolyline || !polylinePath || !currentRouteMaTuyen) {
        showMessage("No route to edit.");
        return;
      }
      if (editMode) return;

      editMode = true;
      awaitingAddNodeClick = false;
      selectedVertexIndex = null;

      // backup original geometry
      originalRouteBackup = [];
      for (let i = 0; i < polylinePath.getLength(); i++) {
        const p = polylinePath.getAt(i);
        originalRouteBackup.push({ lat: p.lat(), lng: p.lng() });
      }

      currentPolyline.setEditable(true);

      showMessage("Route edit mode: drag vertices, click a vertex to Add/Delete.");

      const applyBtn = document.getElementById("applyRouteChangesBtn");
      applyBtn.style.display = "block";
      applyBtn.textContent = `Apply changes to route ${currentRouteMaTuyen}`;

      const cancelBtn = document.getElementById("cancelRouteChangesBtn");
      cancelBtn.style.display = "block";
    }


    function exitRouteEditMode() {
      editMode = false;
      awaitingAddNodeClick = false;
      selectedVertexIndex = null;

      if (currentPolyline) {
        currentPolyline.setEditable(false);
      }

      const applyBtn = document.getElementById("applyRouteChangesBtn");
      if (applyBtn) applyBtn.style.display = "none";

      const cancelBtn = document.getElementById("cancelRouteChangesBtn");
      if (cancelBtn) cancelBtn.style.display = "none";

      if (vertexInfoWindow) vertexInfoWindow.close();

      // clear backup
      originalRouteBackup = null;
    }

    // APPLY CHANGES TO DB

    async function applyRouteChanges() {
      if (!editMode || !currentRouteMaTuyen || !polylinePath || polylinePath.getLength() < 2) {
        showMessage("Nothing to apply.", 3000);
        return;
      }
      showMessage("Saving route geometry...");

      const vertices = [];
      for (let i = 0; i < polylinePath.getLength(); i++) {
        const p = polylinePath.getAt(i);
        vertices.push({ lat: p.lat(), lng: p.lng() });
      }

      try {
        const res = await fetch("/update-route-geometry/", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            MaTuyen: currentRouteMaTuyen,
            Chieu: currentRouteChieu,
            path: vertices,
          }),
        });
        const data = await res.json();
        if (!data.success) {
          showMessage("Failed to save route: " + data.error, 5000);
          return;
        }
        showMessage("Route geometry saved.", 3000);
        exitRouteEditMode();
      } catch (err) {
        console.error(err);
        showMessage("Error saving route geometry.", 5000);
      }
    }


    function isRouteVisible(bounds) {
      const mapBounds = map.getBounds();
      if (!mapBounds) return false;
      return mapBounds.intersects(bounds);
    }

    function cancelRouteChanges() {
      if (!editMode || !originalRouteBackup || !polylinePath) {
        exitRouteEditMode();
        return;
      }

      // restore original points
      polylinePath.clear();
      originalRouteBackup.forEach(pt => {
        polylinePath.push(new google.maps.LatLng(pt.lat, pt.lng));
      });

      showMessage("Changes cancelled.", 2500);

      exitRouteEditMode();
    }

    async function openAddStopPanel(fromStop = false) {
      const panel = document.getElementById("addStopPanel");
      if (!pendingStopLatLng || !currentRouteMaTuyen) return;

      // Fetch existing stops on this route+direction
      let stops = [];
      try {
        const res = await fetch(
          `/route-stops/?MaTuyen=${encodeURIComponent(currentRouteMaTuyen)}&Chieu=${encodeURIComponent(currentRouteChieu)}`
        );
        if (res.ok) {
          const data = await res.json();
          stops = data.stops || [];
        }
      } catch (e) {
        console.error(e);
      }
      routeStopsCache = stops;

      const stopsHtml =
        stops.length === 0
          ? "<i>None yet (only start station)</i>"
          : stops
            .map(
              (s) =>
                `${s.STT}. ${s.TenTram || s.MaTram}`
            )
            .join("<br/>");

      let existingOptions = `<option value="">-- New stop point --</option>`;
      stops.forEach((s) => {
        existingOptions += `<option value="${s.MaTram}">${s.STT}. ${s.TenTram || s.MaTram}</option>`;
      });

      const lat = pendingStopLatLng.lat().toFixed(6);
      const lng = pendingStopLatLng.lng().toFixed(6);

      panel.innerHTML = `
        <div>
          <b>Add stop</b><br/>
          Route ${currentRouteMaTuyen} (${currentRouteChieu === "0" ? "Chiều đi" : "Chiều về"})<br/>
          <small>Click at: ${lat}, ${lng}</small>
          <div style="margin-top:6px;max-height:80px;overflow:auto;border:1px solid #eee;padding:4px;">
            <b>Existing stops on this path:</b><br/>
            ${stopsHtml}
          </div>
          <div style="margin-top:6px;">
            <label style="font-size:12px;">Use existing stop:</label><br/>
            <select id="existingStopSelect" style="width:100%;padding:3px 4px;">
              ${existingOptions}
            </select>
          </div>
          <div id="newStopFields" style="margin-top:6px;">
            <label style="font-size:12px;">New stop name:</label><br/>
            <input id="newStopName" type="text" style="width:100%;padding:3px 4px;margin-bottom:4px;" />
            <label style="font-size:12px;">Type:</label><br/>
            <select id="newStopType" style="width:100%;padding:3px 4px;">
              <option value="1">Bến xe</option>
              <option value="2" selected>Điểm dừng</option>
            </select>
          </div>
          <div style="margin-top:8px;text-align:right;">
            <button id="saveStopBtn" type="button"
                    style="background:#2196F3;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;">
              Save stop
            </button>
            <button id="cancelStopBtn" type="button"
                    style="background:#ccc;color:black;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;margin-left:6px;">
              Cancel
            </button>
          </div>
        </div>
      `;
      panel.style.display = "block";

      const select = document.getElementById("existingStopSelect");
      const newFields = document.getElementById("newStopFields");

      // Hide/show new fields when selecting existing stop
      select.addEventListener("change", () => {
        newFields.style.display = select.value ? "none" : "block";
      });

      // If right-clicking an existing stop → auto-select it
      if (fromStop && pendingRightClickStop) {
        select.value = pendingRightClickStop.MaTram;
        newFields.style.display = "none";
      }

      document.getElementById("cancelStopBtn").onclick = () => {
        panel.style.display = "none";
        pendingStopLatLng = null;
        pendingRightClickStop = null;
      };

      document.getElementById("saveStopBtn").onclick = saveStopFromPanel;

    }

    async function saveStopFromPanel() {
      const panel = document.getElementById("addStopPanel");
      if (!pendingStopLatLng || !currentRouteMaTuyen) return;

      const existingMaTram = document.getElementById("existingStopSelect").value || null;
      let name = null;
      let type = null;

      if (!existingMaTram) {
        name = document.getElementById("newStopName").value.trim();
        type = document.getElementById("newStopType").value;
        if (!name) {
          showMessage("Please enter a name for the new stop.", 3000);
          return;
        }
      }

      const body = {
        MaTuyen: currentRouteMaTuyen,
        Chieu: currentRouteChieu,
        lat: pendingStopLatLng.lat(),
        lng: pendingStopLatLng.lng(),
        ExistingMaTram: existingMaTram,
        TenTram: name,
        MaLoai: type,
      };

      try {
        const res = await fetch("/add-route-stop/", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        const data = await res.json();
        if (!data.success) {
          showMessage("Failed to add stop: " + data.error, 5000);
          return;
        }

        // If new stop created, add marker
        if (data.stop && !existingMaTram) {
          const s = data.stop;
          const stopObj = {
            MaTram: s.MaTram,
            TenTram: s.TenTram,
            lat: s.lat,
            lng: s.lng,
          };
          STOPS.push(stopObj);
          createStopMarker(stopObj); // we'll refactor your marker creation into a function
          updateStopIconsForCurrentRoute();
        }

        showMessage("Stop added to route.", 3000);
        panel.style.display = "none";
        pendingStopLatLng = null;

        updateStopIconsForCurrentRoute();
      } catch (err) {
        console.error(err);
        showMessage("Error adding stop.", 5000);
      }
    }

    function createStopMarker(stop) {
      // default icon based on stop type (off-route)
      let baseIcon =
        stop.MaLoai == 1 ? iconHexagonRed : iconTriangleRed;

      const marker = new google.maps.Marker({
        position: { lat: stop.lat, lng: stop.lng },
        map: map,
        title: stop.TenTram || stop.MaTram,
        icon: baseIcon,
      });


      marker.stopData = stop;

      const stopType = String(stop.MaLoai) === "1" ? "Bến xe" : "Điểm dừng";

      const btnId = `change-location-${stop.MaTram}`;
      const info = new google.maps.InfoWindow({
        content: `
            <div>
              <b>${stop.TenTram || stop.MaTram}</b><br/>
              Mã trạm: ${stop.MaTram}<br/>
              Loại: <b>${stopType}</b><br/>
              <button id="${btnId}" type="button"
                      style="background:#2196F3;color:white;border:none;padding:4px 8px;
                            border-radius:4px;margin-top:5px;cursor:pointer;">
                Change location
              </button>
            </div>
          `,
      });

      marker.addListener("click", () => {
        info.open(map, marker);
        google.maps.event.addListenerOnce(info, "domready", () => {
          const btn = document.getElementById(btnId);
          if (!btn) return;
          btn.onclick = () => {
            selectedStop = marker;
            isChangingLocation = true;
            showMessage("Click a new location on the map to move this stop.");
          };
        });
      });

      marker.addListener("rightclick", () => {
        if (!currentRouteMaTuyen) {
          showMessage("Select a route + direction first.", 3000);
          return;
        }

        // load stop into pending
        pendingStopLatLng = marker.getPosition();
        pendingRightClickStop = stop;    // NEW: store full stop object

        openAddStopPanel(true);  // tell panel we came from a stop
      });


      stopMarkers.push(marker);
    }

    async function updateStopIconsForCurrentRoute() {
      if (!currentRouteMaTuyen) {
        // no route selected -> all stops off-route
        stopMarkers.forEach(m => m.setIcon(stopIconOffRoute));
        return;
      }

      try {
        const res = await fetch(
          `/route-stops/?MaTuyen=${encodeURIComponent(currentRouteMaTuyen)}&Chieu=${encodeURIComponent(currentRouteChieu)}`
        );
        if (!res.ok) {
          console.error("Failed to load route stops", await res.text());
          return;
        }
        const data = await res.json();
        const stops = data.stops || [];

        const onRouteSet = new Set(stops.map(s => s.MaTram));

        stopMarkers.forEach(marker => {
          const maTram = marker.stopData?.MaTram;
          if (maTram && onRouteSet.has(maTram)) {
            // on-route
            if (marker.stopData.MaLoai == 1) {
              marker.setIcon(iconHexagonGreen);   // station
            } else {
              marker.setIcon(iconTriangleGreen);  // normal stop
            }
          } else {
            // off-route
            if (marker.stopData.MaLoai == 1) {
              marker.setIcon(iconHexagonRed);
            } else {
              marker.setIcon(iconTriangleRed);
            }
          }

        });
      } catch (err) {
        console.error("Error updating stop icons:", err);
      }
    }



    window.onload = function () {
      initMap();

      document.getElementById("routeSelect").addEventListener("change", loadAndDrawRoute);
      document.getElementById("directionSelect").addEventListener("change", loadAndDrawRoute);

      document.getElementById("applyRouteChangesBtn").addEventListener("click", applyRouteChanges);
      document.getElementById("cancelRouteChangesBtn").addEventListener("click", cancelRouteChanges);

    };
  </script>

</body>

</html>